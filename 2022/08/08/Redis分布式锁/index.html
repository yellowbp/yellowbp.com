<!DOCTYPE html>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta http-equiv="Cache-Control" content="no-siteapp">
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no">
  <meta name="renderer" content="webkit">

  
  <title>Redis分布式锁 | bp的Blog</title>

  <link rel="shortcut icon" href="/images/favicon.png">
  
  <meta name="description" content="Redis 分布式锁什么是分布式锁分布式锁其实就是，控制分布式系统不同进程共同访问共享资源的一种锁的实现。如果不同的系统或同一个系统的不同主机之间共享了某个临界资源，往往需要互斥来防止彼此干扰，以保证一致性。 举个生活中的案例：可以把锁看成房门外的一把锁，所有并发线程比作人，他们都想进入房间，房间内只能有一个人进入。当有人进入后，将门反锁，其他人必须等待，直到进去的人出来。 分布式锁特性 互斥性：">
<meta name="keywords" content="redis">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis分布式锁">
<meta property="og:url" content="https://yellowbp.github.io/2022/08/08/Redis分布式锁/index.html">
<meta property="og:site_name" content="bp的Blog">
<meta property="og:description" content="Redis 分布式锁什么是分布式锁分布式锁其实就是，控制分布式系统不同进程共同访问共享资源的一种锁的实现。如果不同的系统或同一个系统的不同主机之间共享了某个临界资源，往往需要互斥来防止彼此干扰，以保证一致性。 举个生活中的案例：可以把锁看成房门外的一把锁，所有并发线程比作人，他们都想进入房间，房间内只能有一个人进入。当有人进入后，将门反锁，其他人必须等待，直到进去的人出来。 分布式锁特性 互斥性：">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="h:/images/分布式锁redis/分布式锁的基本原理.png">
<meta property="og:image" content="h:%5Cimages%5C%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81redis%5Csetnx.png">
<meta property="og:image" content="h:/images/分布式锁redis/青铜.png">
<meta property="og:image" content="h:/images/分布式锁redis/白银.png">
<meta property="og:image" content="h:/images/分布式锁redis/黄金.png">
<meta property="og:image" content="h:/images/分布式锁redis/铂金.png">
<meta property="og:image" content="h:/images/分布式锁redis/钻石.png">
<meta property="og:image" content="h:/images/分布式锁redis/可重入锁.png">
<meta property="og:image" content="h:/images/分布式锁redis/王者.png">
<meta property="og:image" content="h:/images/分布式锁redis/redis集群抢占锁问题.png">
<meta property="og:updated_time" content="2022-08-22T12:19:51.123Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Redis分布式锁">
<meta name="twitter:description" content="Redis 分布式锁什么是分布式锁分布式锁其实就是，控制分布式系统不同进程共同访问共享资源的一种锁的实现。如果不同的系统或同一个系统的不同主机之间共享了某个临界资源，往往需要互斥来防止彼此干扰，以保证一致性。 举个生活中的案例：可以把锁看成房门外的一把锁，所有并发线程比作人，他们都想进入房间，房间内只能有一个人进入。当有人进入后，将门反锁，其他人必须等待，直到进去的人出来。 分布式锁特性 互斥性：">
<meta name="twitter:image" content="h:/images/分布式锁redis/分布式锁的基本原理.png">

  <meta name="format-detection" content="telephone=no,email=no">
  <meta name="theme-color" content="#9C27B0">
  <meta name="description" content>
  <meta name="keywords" content=",redis">

  <meta name="mobile-web-app-capable" content="yes">
  <meta name="application-name" content="bp的Blog">
  <meta name="msapplication-starturl" content="https://yellowbp.github.io/2022/08/08/Redis分布式锁/">
  <meta name="msapplication-navbutton-color" content="#9C27B0">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-title" content="bp的Blog">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <link rel="apple-touch-icon" href="/images/favicon.png">

  
    <meta property="article:published_time" content="Mon Aug 08 2022 17:45:32 GMT+0800">
    <meta property="article:modified_time" content="Mon Aug 22 2022 20:19:51 GMT+0800">
  

  
    <link rel="canonical" href="https://yellowbp.github.io/2022/08/08/Redis分布式锁/">
  

  <meta name="google-site-verification" content="fXjtlIfaDc_X-0P11rO3bEp1Nk4IKXphoJv0GqGZCco">
  <meta name="baidu-site-verification" content="I3t1wfwZvd">

  <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create','UA-139531378-1','auto');ga('send','pageview');
</script>
  <script>
  var _hmt = _hmt || [];
  (function() {var hm = document.createElement('script');
  hm.src = 'https://hm.baidu.com/hm.js?1054d51c0b66f1d168829173682c8159';
  var s = document.getElementsByTagName('script')[0];
  s.parentNode.insertBefore(hm, s);
  })();
</script>
  

  <link rel="stylesheet" href="/css/mdui.css">
<link rel="stylesheet" href="/css/style.css">
</head>
<body class="mdui-appbar-with-toolbar mdui-drawer-body-left mdui-theme-primary-brown mdui-theme-accent-blue">
  <script>var a=localStorage.getItem("mdui-theme-layout-dark");if(a){document.getElementsByTagName("body")[0].className+=" mdui-theme-layout-dark"};</script>
  <header id="header" class="mdui-appbar mdui-appbar-fixed mdui-appbar-scroll-hide mdui-appbar-inset">
  <div class="mdui-toolbar mdui-color-theme">
    <a href="javascript:;" class="mdui-btn mdui-btn-icon" mdui-drawer="{target: '#sidebar', swipe: true}"><i class="mdui-icon material-icons">menu</i></a>
    <a href="/" class="mdui-typo-headline">bp的Blog</a>
    <div class="mdui-toolbar-spacer"></div>
    <a href="javascript:;" class="mdui-btn mdui-btn-icon" mdui-dialog="{target: '#search'}" mdui-tooltip="{content: '搜索'}"><i class="mdui-icon material-icons">search</i></a>
    
  </div>
</header>
<div class="mdui-dialog" id="search">
  
    <div class="search-form">
      <input type="search" class="search-form-input" placeholder="请输入关键字">
    </div>
    <div class="search-result" data-resource="/search.xml"></div>
  
</div>
  <aside id="sidebar" class="mdui-drawer mdui-drawer-full-height">
  <div class="mdui-grid-tile">
    <img src="/images/Gradient1.jpg" style="height: 160px;">
    <img src="/images/headPic.jpg" class="avatar-animation" style="position: absolute; top: 10%; left: 24px; width: 64px; height: 64px; border: 2px solid #fff; border-radius: 50%;">
    <div class="mdui-grid-tile-actions">
      <div class="mdui-grid-tile-text">
        <div class="mdui-grid-tile-title">hbp
        </div>
        <div class="mdui-grid-tile-subtitle"><i class="mdui-icon material-icons">art_track</i>要想快，先会慢</div>
      </div>
      
        <div class="mdui-grid-tile-buttons">
          <a href="mailto:347070556@qq.com" class="mdui-btn mdui-btn-icon" mdui-tooltip="{content: '347070556@qq.com'}"><i class="mdui-icon material-icons">email</i></a>
        </div>
      
    </div>
  </div>

  <div class="mdui-list" mdui-collapse="{accordion: true}">
    <a href="/" class="mdui-list-item mdui-ripple">
      <i class="mdui-list-item-icon mdui-icon material-icons mdui-text-color-blue">home</i>
      <div class="mdui-list-item-content">主页</div>
    </a>
    <div class="mdui-collapse-item">
      <div class="mdui-collapse-item-header mdui-list-item mdui-ripple">
        <i class="mdui-list-item-icon mdui-icon material-icons mdui-text-color-deep-orange">inbox</i>
        <div class="mdui-list-item-content">归档</div>
        <i class="mdui-collapse-item-arrow mdui-icon material-icons">keyboard_arrow_down</i>
      </div>
      <div class="mdui-collapse-item-body mdui-list mdui-list-dense">
        
        <a class="mdui-ripple sidebar_archives-link" href="/archives/2022/08/">八月 2022<span class="mdui-ripple sidebar_archives-count">1</span></a><a class="mdui-ripple sidebar_archives-link" href="/archives/2022/07/">七月 2022<span class="mdui-ripple sidebar_archives-count">10</span></a><a class="mdui-ripple sidebar_archives-link" href="/archives/2022/05/">五月 2022<span class="mdui-ripple sidebar_archives-count">1</span></a><a class="mdui-ripple sidebar_archives-link" href="/archives/2022/04/">四月 2022<span class="mdui-ripple sidebar_archives-count">4</span></a><a class="mdui-ripple sidebar_archives-link" href="/archives/2022/03/">三月 2022<span class="mdui-ripple sidebar_archives-count">1</span></a><a class="mdui-ripple sidebar_archives-link" href="/archives/2022/02/">二月 2022<span class="mdui-ripple sidebar_archives-count">13</span></a><a class="mdui-ripple sidebar_archives-link" href="/archives/2021/10/">十月 2021<span class="mdui-ripple sidebar_archives-count">9</span></a><a class="mdui-ripple sidebar_archives-link" href="/archives/2021/09/">九月 2021<span class="mdui-ripple sidebar_archives-count">1</span></a><a class="mdui-ripple sidebar_archives-link" href="/archives/2021/08/">八月 2021<span class="mdui-ripple sidebar_archives-count">5</span></a><a class="mdui-ripple sidebar_archives-link" href="/archives/2021/07/">七月 2021<span class="mdui-ripple sidebar_archives-count">10</span></a><a class="mdui-ripple sidebar_archives-link" href="/archives/2021/06/">六月 2021<span class="mdui-ripple sidebar_archives-count">3</span></a><a class="mdui-ripple sidebar_archives-link" href="/archives/2021/05/">五月 2021<span class="mdui-ripple sidebar_archives-count">5</span></a><a class="mdui-ripple sidebar_archives-link" href="/archives/2021/04/">四月 2021<span class="mdui-ripple sidebar_archives-count">1</span></a><a class="mdui-ripple sidebar_archives-link" href="/archives/2021/03/">三月 2021<span class="mdui-ripple sidebar_archives-count">12</span></a><a class="mdui-ripple sidebar_archives-link" href="/archives/2021/02/">二月 2021<span class="mdui-ripple sidebar_archives-count">4</span></a><a class="mdui-ripple sidebar_archives-link" href="/archives/2021/01/">一月 2021<span class="mdui-ripple sidebar_archives-count">2</span></a><a class="mdui-ripple sidebar_archives-link" href="/archives/2020/03/">三月 2020<span class="mdui-ripple sidebar_archives-count">3</span></a><a class="mdui-ripple sidebar_archives-link" href="/archives/2019/12/">十二月 2019<span class="mdui-ripple sidebar_archives-count">2</span></a><a class="mdui-ripple sidebar_archives-link" href="/archives/2019/11/">十一月 2019<span class="mdui-ripple sidebar_archives-count">5</span></a><a class="mdui-ripple sidebar_archives-link" href="/archives/2019/10/">十月 2019<span class="mdui-ripple sidebar_archives-count">3</span></a><a class="mdui-ripple sidebar_archives-link" href="/archives/2019/09/">九月 2019<span class="mdui-ripple sidebar_archives-count">3</span></a><a class="mdui-ripple sidebar_archives-link" href="/archives/2019/08/">八月 2019<span class="mdui-ripple sidebar_archives-count">5</span></a>
        
      </div>
    </div>
    <div class="mdui-collapse-item">
      <div class="mdui-collapse-item-header mdui-list-item mdui-ripple">
        <i class="mdui-list-item-icon mdui-icon material-icons mdui-text-color-green">chrome_reader_mode</i>
        <div class="mdui-list-item-content">分类</div>
        <i class="mdui-collapse-item-arrow mdui-icon material-icons">keyboard_arrow_down</i>
      </div>
      <div class="mdui-collapse-item-body mdui-list mdui-list-dense">
        
        <a class="mdui-ripple sidebar_archives-link" href="/categories/ElasticSearch/">ElasticSearch<span class="mdui-ripple sidebar_archives-count">2</span></a><a class="mdui-ripple sidebar_archives-link" href="/categories/OAuth2/">OAuth2<span class="mdui-ripple sidebar_archives-count">8</span></a><a class="mdui-ripple sidebar_archives-link" href="/categories/Redis/">Redis<span class="mdui-ripple sidebar_archives-count">1</span></a><a class="mdui-ripple sidebar_archives-link" href="/categories/Spring/">Spring<span class="mdui-ripple sidebar_archives-count">2</span></a><a class="mdui-ripple sidebar_archives-link" href="/categories/SpringBoot/">SpringBoot<span class="mdui-ripple sidebar_archives-count">2</span></a><a class="mdui-ripple sidebar_archives-link" href="/categories/SpringCloud-Alibaba/">SpringCloud Alibaba<span class="mdui-ripple sidebar_archives-count">7</span></a><a class="mdui-ripple sidebar_archives-link" href="/categories/SpringMVC/">SpringMVC<span class="mdui-ripple sidebar_archives-count">1</span></a><a class="mdui-ripple sidebar_archives-link" href="/categories/docker/">docker<span class="mdui-ripple sidebar_archives-count">1</span></a><a class="mdui-ripple sidebar_archives-link" href="/categories/excel/">excel<span class="mdui-ripple sidebar_archives-count">3</span></a><a class="mdui-ripple sidebar_archives-link" href="/categories/git/">git<span class="mdui-ripple sidebar_archives-count">1</span></a><a class="mdui-ripple sidebar_archives-link" href="/categories/java8/">java8<span class="mdui-ripple sidebar_archives-count">4</span></a><a class="mdui-ripple sidebar_archives-link" href="/categories/java基础/">java基础<span class="mdui-ripple sidebar_archives-count">3</span></a><a class="mdui-ripple sidebar_archives-link" href="/categories/jenkins/">jenkins<span class="mdui-ripple sidebar_archives-count">3</span></a><a class="mdui-ripple sidebar_archives-link" href="/categories/jenkins/docker/">docker<span class="mdui-ripple sidebar_archives-count">2</span></a><a class="mdui-ripple sidebar_archives-link" href="/categories/jwt/">jwt<span class="mdui-ripple sidebar_archives-count">1</span></a><a class="mdui-ripple sidebar_archives-link" href="/categories/k8s/">k8s<span class="mdui-ripple sidebar_archives-count">10</span></a><a class="mdui-ripple sidebar_archives-link" href="/categories/linux/">linux<span class="mdui-ripple sidebar_archives-count">2</span></a><a class="mdui-ripple sidebar_archives-link" href="/categories/maven/">maven<span class="mdui-ripple sidebar_archives-count">1</span></a><a class="mdui-ripple sidebar_archives-link" href="/categories/mq/">mq<span class="mdui-ripple sidebar_archives-count">1</span></a><a class="mdui-ripple sidebar_archives-link" href="/categories/mybatis/">mybatis<span class="mdui-ripple sidebar_archives-count">1</span></a><a class="mdui-ripple sidebar_archives-link" href="/categories/mysql/">mysql<span class="mdui-ripple sidebar_archives-count">4</span></a><a class="mdui-ripple sidebar_archives-link" href="/categories/nginx/">nginx<span class="mdui-ripple sidebar_archives-count">1</span></a><a class="mdui-ripple sidebar_archives-link" href="/categories/redis/">redis<span class="mdui-ripple sidebar_archives-count">1</span></a><a class="mdui-ripple sidebar_archives-link" href="/categories/servlet/">servlet<span class="mdui-ripple sidebar_archives-count">1</span></a><a class="mdui-ripple sidebar_archives-link" href="/categories/spring/">spring<span class="mdui-ripple sidebar_archives-count">1</span></a><a class="mdui-ripple sidebar_archives-link" href="/categories/ssm/">ssm<span class="mdui-ripple sidebar_archives-count">2</span></a><a class="mdui-ripple sidebar_archives-link" href="/categories/web开发基础/">web开发基础<span class="mdui-ripple sidebar_archives-count">1</span></a><a class="mdui-ripple sidebar_archives-link" href="/categories/yaml/">yaml<span class="mdui-ripple sidebar_archives-count">1</span></a><a class="mdui-ripple sidebar_archives-link" href="/categories/上传下载文件/">上传下载文件<span class="mdui-ripple sidebar_archives-count">1</span></a><a class="mdui-ripple sidebar_archives-link" href="/categories/乱码/">乱码<span class="mdui-ripple sidebar_archives-count">1</span></a><a class="mdui-ripple sidebar_archives-link" href="/categories/参数校验/">参数校验<span class="mdui-ripple sidebar_archives-count">1</span></a><a class="mdui-ripple sidebar_archives-link" href="/categories/发短信/">发短信<span class="mdui-ripple sidebar_archives-count">1</span></a><a class="mdui-ripple sidebar_archives-link" href="/categories/小程序/">小程序<span class="mdui-ripple sidebar_archives-count">1</span></a><a class="mdui-ripple sidebar_archives-link" href="/categories/工具类/">工具类<span class="mdui-ripple sidebar_archives-count">1</span></a><a class="mdui-ripple sidebar_archives-link" href="/categories/开发软件/">开发软件<span class="mdui-ripple sidebar_archives-count">2</span></a><a class="mdui-ripple sidebar_archives-link" href="/categories/技术/">技术<span class="mdui-ripple sidebar_archives-count">1</span></a><a class="mdui-ripple sidebar_archives-link" href="/categories/搭建博客/">搭建博客<span class="mdui-ripple sidebar_archives-count">1</span></a><a class="mdui-ripple sidebar_archives-link" href="/categories/电脑硬件/">电脑硬件<span class="mdui-ripple sidebar_archives-count">1</span></a><a class="mdui-ripple sidebar_archives-link" href="/categories/算法/">算法<span class="mdui-ripple sidebar_archives-count">7</span></a><a class="mdui-ripple sidebar_archives-link" href="/categories/缓存/">缓存<span class="mdui-ripple sidebar_archives-count">2</span></a><a class="mdui-ripple sidebar_archives-link" href="/categories/规范/">规范<span class="mdui-ripple sidebar_archives-count">3</span></a><a class="mdui-ripple sidebar_archives-link" href="/categories/认证授权/">认证授权<span class="mdui-ripple sidebar_archives-count">3</span></a><a class="mdui-ripple sidebar_archives-link" href="/categories/设计模式/">设计模式<span class="mdui-ripple sidebar_archives-count">6</span></a><a class="mdui-ripple sidebar_archives-link" href="/categories/部署/">部署<span class="mdui-ripple sidebar_archives-count">1</span></a><a class="mdui-ripple sidebar_archives-link" href="/categories/重装/">重装<span class="mdui-ripple sidebar_archives-count">1</span></a>
        
      </div>
    </div>
    <div class="mdui-collapse-item">
      <div class="mdui-collapse-item-header mdui-list-item mdui-ripple">
        <i class="mdui-list-item-icon mdui-icon material-icons mdui-text-color-brown">bookmark</i>
        <div class="mdui-list-item-content">标签</div>
        <i class="mdui-collapse-item-arrow mdui-icon material-icons">keyboard_arrow_down</i>
      </div>
      <div class="mdui-collapse-item-body mdui-list mdui-list-dense">
        
        <a class="mdui-ripple sidebar_archives-link" href="/tags/Spring/">Spring<span class="mdui-ripple sidebar_archives-count">22</span></a><a class="mdui-ripple sidebar_archives-link" href="/tags/algorithm/">algorithm<span class="mdui-ripple sidebar_archives-count">7</span></a><a class="mdui-ripple sidebar_archives-link" href="/tags/excel/">excel<span class="mdui-ripple sidebar_archives-count">5</span></a><a class="mdui-ripple sidebar_archives-link" href="/tags/git/">git<span class="mdui-ripple sidebar_archives-count">13</span></a><a class="mdui-ripple sidebar_archives-link" href="/tags/hexo/">hexo<span class="mdui-ripple sidebar_archives-count">1</span></a><a class="mdui-ripple sidebar_archives-link" href="/tags/javaWeb/">javaWeb<span class="mdui-ripple sidebar_archives-count">7</span></a><a class="mdui-ripple sidebar_archives-link" href="/tags/java基础/">java基础<span class="mdui-ripple sidebar_archives-count">2</span></a><a class="mdui-ripple sidebar_archives-link" href="/tags/jwt/">jwt<span class="mdui-ripple sidebar_archives-count">1</span></a><a class="mdui-ripple sidebar_archives-link" href="/tags/linux/">linux<span class="mdui-ripple sidebar_archives-count">4</span></a><a class="mdui-ripple sidebar_archives-link" href="/tags/mq/">mq<span class="mdui-ripple sidebar_archives-count">1</span></a><a class="mdui-ripple sidebar_archives-link" href="/tags/mysql/">mysql<span class="mdui-ripple sidebar_archives-count">6</span></a><a class="mdui-ripple sidebar_archives-link" href="/tags/nginx/">nginx<span class="mdui-ripple sidebar_archives-count">1</span></a><a class="mdui-ripple sidebar_archives-link" href="/tags/redis/">redis<span class="mdui-ripple sidebar_archives-count">9</span></a><a class="mdui-ripple sidebar_archives-link" href="/tags/servlet/">servlet<span class="mdui-ripple sidebar_archives-count">1</span></a><a class="mdui-ripple sidebar_archives-link" href="/tags/spring/">spring<span class="mdui-ripple sidebar_archives-count">1</span></a><a class="mdui-ripple sidebar_archives-link" href="/tags/web开发基础/">web开发基础<span class="mdui-ripple sidebar_archives-count">3</span></a><a class="mdui-ripple sidebar_archives-link" href="/tags/win7/">win7<span class="mdui-ripple sidebar_archives-count">1</span></a><a class="mdui-ripple sidebar_archives-link" href="/tags/其他/">其他<span class="mdui-ripple sidebar_archives-count">4</span></a><a class="mdui-ripple sidebar_archives-link" href="/tags/分布式/">分布式<span class="mdui-ripple sidebar_archives-count">1</span></a><a class="mdui-ripple sidebar_archives-link" href="/tags/接口文档/">接口文档<span class="mdui-ripple sidebar_archives-count">2</span></a><a class="mdui-ripple sidebar_archives-link" href="/tags/笔记本选购/">笔记本选购<span class="mdui-ripple sidebar_archives-count">1</span></a><a class="mdui-ripple sidebar_archives-link" href="/tags/自动化构建工具/">自动化构建工具<span class="mdui-ripple sidebar_archives-count">1</span></a><a class="mdui-ripple sidebar_archives-link" href="/tags/设计模式/">设计模式<span class="mdui-ripple sidebar_archives-count">6</span></a>
        
      </div>
    </div>
    <a href="/about" class="mdui-list-item mdui-ripple">
      <i class="mdui-list-item-icon mdui-icon material-icons mdui-text-color-purple">person</i>
      <div class="mdui-list-item-content">关于</div>
    </a>
  </div>

  <div class="mdui-divider"></div>

  <div class="mdui-list" mdui-collapse="{accordion: true}">
    
    <div class="mdui-collapse-item">
      <div class="mdui-collapse-item-header mdui-list-item mdui-ripple">
        <div class="mdui-list-item-content">友情链接</div>
        <i class="mdui-list-item-icon mdui-icon material-icons">link</i>
      </div>
      <div class="mdui-collapse-item-body mdui-list mdui-list-dense">
        
        
          <a href="javascript:;" class="mdui-list-item mdui-ripple mdui-p-l-2 mdui-text-color-theme" style="justify-content: center;">链接为空</a>
        
      </div>
    </div>
  </div>
</aside>
  <main id="main" class="mdui-m-t-5 fadeIn animated">
  <link rel="stylesheet" href="https://cdn.bootcss.com/fancybox/3.5.7/jquery.fancybox.min.css">
  <style>#main article .mdui-card-content .center-block{display:block!important;margin-right:auto!important;margin-left:auto!important}</style>
  <article class="mdui-card mdui-m-b-5">
    <header class="mdui-card-media">
      <img src="/images/random/material-16.png" style="max-height: 240px;">
      <div class="mdui-card-media-covered">
        <div class="mdui-card-primary">
          <div class="mdui-card-primary-title">Redis分布式锁</div>
          <div class="mdui-card-primary-subtitle"><i class="iconfont">&#xe697;</i> 2022-08-08 / 
          <i class="iconfont">&#xe601;</i> hbp
          <span id="busuanzi_container_page_pv">
            本文总阅读量<span id="busuanzi_value_page_pv"></span>次
          </span>
          </div>
        </div>
      </div>
      <div class="mdui-card-menu">
        
        
      </div>
    </header>
    <div class="mdui-card-content mdui-typo">
      <h1 id="Redis-分布式锁"><a href="#Redis-分布式锁" class="headerlink" title="Redis 分布式锁"></a>Redis 分布式锁</h1><h2 id="什么是分布式锁"><a href="#什么是分布式锁" class="headerlink" title="什么是分布式锁"></a>什么是分布式锁</h2><p>分布式锁其实就是，控制分布式系统不同进程共同访问共享资源的一种锁的实现。如果不同的系统或同一个系统的不同主机之间共享了某个临界资源，往往需要互斥来防止彼此干扰，以保证一致性。</p>
<p>举个生活中的案例：可以把锁看成房门外的一把<code>锁</code>，所有并发线程比作<code>人</code>，他们都想进入房间，房间内只能有一个人进入。当有人进入后，将门反锁，其他人必须等待，直到进去的人出来。</p>
<h2 id="分布式锁特性"><a href="#分布式锁特性" class="headerlink" title="分布式锁特性"></a>分布式锁特性</h2><ul>
<li>互斥性：任意时刻，只有一个客户端能持有锁</li>
<li>锁超时释放：持有锁超时，可以释放，防止死锁</li>
<li>可重入性：一个线程获取了锁之后，可以再次对其请求加锁</li>
<li>高可用、高性能：加锁和解锁需要开销尽可能低，同时也要保持高可用</li>
<li>安全性：锁只能被持有的客户端删除，不能被其他客户端删除</li>
</ul>
<p>我们来看下分布式锁的基本原理，如下图所示：</p>
<img src="H:\images\分布式锁redis\分布式锁的基本原理.png" alt="分布式锁的基本原理" style="zoom:67%;">

<p>我们来分析下上图的分布式锁：</p>
<ol>
<li>高并发情况下，前端请求通过网关，将请求转发给各个节点的商品服务</li>
<li>每个处理请求的线程在执行业务之前，需要先抢占锁。可以理解为“占坑”</li>
<li>获取到锁的线程在执行完业务后，释放锁。可以理解为“释放坑位”。</li>
<li>未获取到的线程需要等待锁释放。</li>
<li>释放锁后，其他线程抢占锁。</li>
<li>重复执行步骤 3 4 5</li>
</ol>
<p>大白话解释：所有请求的线程都去同一个地方 <code>占坑</code>，如果有坑位，就执行业务逻辑，没有坑位，就需要其他线程释放“坑位”。这个坑位是所有线程可见的，可以把这个坑位放到 Redis 缓存或者数据库，这篇讲的就是如何用 Redis 做 <code>分布式坑位</code></p>
<h2 id="Redis的setnx"><a href="#Redis的setnx" class="headerlink" title="Redis的setnx"></a>Redis的setnx</h2><p>Redis 作为一个公共可访问的地方，正好可以作为“占坑”的地方。</p>
<p>用 Redis 实现分布式锁的几种方案，我们都是用 SETNX 命令（设置 key 等于某 value）。只是高阶方案传的参数个数不一样，以及考虑了异常情况。</p>
<p>我们来看下这个命令，<code>setnx</code>是<code>set If not exist</code>的简写。意思就是当 key 不存在时，设置 key 的值，存在时，什么都不做。</p>
<p>在 Redis 命令行中是这样执行的：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set &lt;key&gt; &lt;value&gt; NX</span><br></pre></td></tr></table></figure>

<p>返回 <code>OK</code>，表示设置成功。重复执行该命令，返回 <code>nil</code>表示设置失败。</p>
<p><img src="H:%5Cimages%5C%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81redis%5Csetnx.png" alt="setnx"></p>
<blockquote>
<p>以下方案是改进的演进方案</p>
</blockquote>
<h2 id="分布式方案"><a href="#分布式方案" class="headerlink" title="分布式方案"></a>分布式方案</h2><h3 id="方案一：setnx"><a href="#方案一：setnx" class="headerlink" title="方案一：setnx"></a>方案一：setnx</h3><p>我们先用 Redis 的 SETNX 命令来实现最简单的分布式锁。</p>
<p>流程图：</p>
<img src="H:\images\分布式锁redis\青铜.png" alt="青铜" style="zoom:67%;">

<ul>
<li>多个并发线程都去 Redis 中申请锁，也就是执行 setnx 命令，假设线程 A 执行成功，说明当前线程 A 获得了。</li>
<li>其他线程执行 setnx 命令都会是失败的，所以需要等待线程 A 释放锁。</li>
<li>线程 A 执行完自己的业务后，删除锁。</li>
<li>其他线程继续抢占锁，也就是执行 setnx 命令。因为线程 A 已经删除（释放）了锁，所以又有其他线程可以抢占到锁了。</li>
</ul>
<p>代码示例如下，Java 中 setnx 命令对应的代码为 <code>setIfAbsent</code></p>
<p>setIfAbsent 方法的第一个参数代表 key，第二个参数代表值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getTypeEntityListByRedisDistributedLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 先抢占锁</span></span><br><span class="line">    Boolean lock = redisTemplate.opsForValue().setIfAbsent(<span class="string">"lock"</span>, <span class="number">123</span>);</span><br><span class="line">    <span class="keyword">if</span> (lock) &#123;</span><br><span class="line">        <span class="comment">// 2. 抢占锁成功，执行业务</span></span><br><span class="line">        log.info(<span class="string">"[执行业务...]"</span>);</span><br><span class="line">        <span class="comment">// 3. 解锁</span></span><br><span class="line">        redisTemplate.delete(<span class="string">"lock"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 休眠一段时间</span></span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        <span class="comment">// 抢占失败，100ms后进行重试，等待锁释放</span></span><br><span class="line">        getTypeEntityListByRedisDistributedLock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个小问题：那为什么需要休眠一段时间？</p>
<p>因为该程序存在递归调用，执行太快可能会导致栈空间溢出。</p>
<h4 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h4><p>设想一种场景：晚上张三一个人开锁进入了房间，打开了电灯，然后突然<code>断电</code>了，张三想开门出去，但是找不到门锁位置，那张三就进不去了，外面的人也进不来。</p>
<p>从技术的角度看：setnx 占锁成功，业务代码出现异常或者服务器宕机，没有执行删除锁的逻辑，就造成了<code>死锁</code>。</p>
<p><strong>那如何规避这个风险呢？</strong></p>
<p>设置锁的<code>自动过期时间</code>，过一段时间后，自动删除锁，这样其他线程就能获取到锁了。</p>
<h3 id="方案二：setnx-expire"><a href="#方案二：setnx-expire" class="headerlink" title="方案二：setnx+ expire"></a>方案二：setnx+ expire</h3><p>小空开锁成功后，给这款智能锁设置了一个<code>沙漏倒计时⏳</code>，沙漏完后，门锁自动打开。即使房间突然断电，过一段时间后，锁会自动打开，其他人就可以进来了。</p>
<p>在占锁成功后，设置锁的过期时间，这两步是分步执行的。如下图所示：</p>
<h4 id="原理图"><a href="#原理图" class="headerlink" title="原理图"></a>原理图</h4><img src="H:\images\分布式锁redis\白银.png" alt="白银" style="zoom:67%;">

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getTypeEntityListByRedisDistributedLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 先抢占锁</span></span><br><span class="line">        <span class="keyword">boolean</span> lock = redisTemplate.opsForValue().setIfAbsent(<span class="string">"lock"</span>, <span class="number">123</span>);</span><br><span class="line">        <span class="keyword">if</span> (lock) &#123;</span><br><span class="line">            <span class="comment">// 2.在 5s 以后，自动清理 lock</span></span><br><span class="line">            redisTemplate.expire(<span class="string">"lock"</span>, <span class="number">5</span>, TimeUnit.SECONDS);</span><br><span class="line">            <span class="comment">// 3. 抢占锁成功，执行业务</span></span><br><span class="line">            log.info(<span class="string">"[执行业务...]"</span>);</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">			<span class="comment">// System.out.println(1/0);</span></span><br><span class="line">            <span class="comment">// 4. 解锁</span></span><br><span class="line">            redisTemplate.delete(<span class="string">"lock"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 休眠一段时间</span></span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            <span class="comment">// 抢占失败，100ms后进行重试，等待锁释放</span></span><br><span class="line">            getTypeEntityListByRedisDistributedLock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="缺陷-1"><a href="#缺陷-1" class="headerlink" title="缺陷"></a>缺陷</h4><p>案看似解决了线程异常或服务器宕机造成的锁未释放的问题，但还是存在其他问题：</p>
<p>因为占锁和设置过期时间是分两步执行的，所以如果在这两步之间发生了异常，则锁的过期时间根本就没有设置成功。</p>
<p>所以和青铜方案有一样的问题：<strong>锁永远不能过期</strong>。</p>
<h3 id="方案三：setpx"><a href="#方案三：setpx" class="headerlink" title="方案三：setpx"></a>方案三：setpx</h3><p>上面的白银方案中，占锁和设置锁过期时间是分步两步执行的，这个时候，我们可以联想到什么：事务的原子性（Atom）</p>
<p><strong>原子性</strong>：多条命令要么都成功执行，要么都不执行。</p>
<p>将两步放在一步中执行：占锁+设置锁过期时间。</p>
<p>Redis 正好支持这种操作：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 设置某个 key 的值并设置多少毫秒或秒 过期。</span></span><br><span class="line">set &lt;key&gt; &lt;value&gt; PX &lt;多少毫秒&gt; NX</span><br><span class="line">或</span><br><span class="line">set &lt;key&gt; &lt;value&gt; EX &lt;多少秒&gt; NX</span><br></pre></td></tr></table></figure>

<p>然后可以通过如下命令查看 key 的变化</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ttl &lt;key&gt;</span><br></pre></td></tr></table></figure>

<p>下面演示下如何设置 key 并设置过期时间。注意：执行命令之前需要先删除 key，可以通过客户端或命令删除。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 设置 key=wukong，value=1111，过期时间=5000ms</span></span><br><span class="line">set lock 1111 PX 5000 NX</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看 key 的状态；-2表示过期</span></span><br><span class="line">ttl lock</span><br></pre></td></tr></table></figure>

<h4 id="原理图-1"><a href="#原理图-1" class="headerlink" title="原理图"></a>原理图</h4><img src="H:\images\分布式锁redis\黄金.png" alt="黄金" style="zoom:67%;">

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getTypeEntityListByRedisDistributedLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 先抢占锁</span></span><br><span class="line">        <span class="keyword">boolean</span> lock = redisTemplate.opsForValue().setIfAbsent(<span class="string">"lock"</span>, <span class="number">123</span>, <span class="number">5</span>, TimeUnit.SECONDS);</span><br><span class="line">        <span class="keyword">if</span> (lock) &#123;</span><br><span class="line">            <span class="comment">// 2. 抢占锁成功，执行业务</span></span><br><span class="line">            log.info(<span class="string">"[执行业务...]"</span>);</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line"><span class="comment">//            System.out.println(1/0);</span></span><br><span class="line">            <span class="comment">// 4. 解锁</span></span><br><span class="line">            redisTemplate.delete(<span class="string">"lock"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 休眠一段时间</span></span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            <span class="comment">// 抢占失败，100ms后进行重试，等待锁释放</span></span><br><span class="line">            getTypeEntityListByRedisDistributedLock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="缺陷-2"><a href="#缺陷-2" class="headerlink" title="缺陷"></a>缺陷</h4><ul>
<li>线程 A 先抢占到了锁，并设置了这个锁 10 秒以后自动开锁，锁的value为 <code>123</code></li>
<li>10 秒以后，A 还在执行任务，此时锁被自动打开了</li>
<li>线程 B 看到锁打开了，于是抢占到了锁，设置锁的value同样为 <code>123</code>，并设置了过期时间 <code>10 秒</code></li>
<li>因当前资源只允许一个线程执行任务，所以线程 A 和 线程 B 执行任务<code>产生了冲突</code></li>
<li>线程 A 在 <code>15 s</code> 后，完成了任务，此时 用户 B 还在执行任务</li>
<li>此时线程A 执行完任务后，会释放value为 <code>123</code>的锁</li>
<li>而此时线程B 还在执行任务，却发现锁已经被释放了</li>
<li>此时线程C 也来了，由此重复以上步骤</li>
</ul>
<p>从上面的案例中我们可以知道，因为线程 A 处理任务所需要的时间<strong>大于</strong>锁自动释放的时间，所以在释放锁后，又有其他用户抢占到了锁。当线程 A 完成任务后，会把其他线程抢占到的锁给主动释放</p>
<p><strong>这里为什么会释放别人的锁？</strong>因为锁的value都叫做 <code>“123”</code>，线程 A 只认锁的value，看见value为 <code>“123”</code>的锁就开，结果把线程 B 的锁释放了，此时线程 B 还未执行完任务</p>
<h3 id="方案四：sexpx-uuid"><a href="#方案四：sexpx-uuid" class="headerlink" title="方案四：sexpx + uuid"></a>方案四：sexpx + uuid</h3><p>基于以上黄金方案的缺陷，给每个锁设置<strong>不同的value</strong>不就好了</p>
<ol>
<li>设置锁的过期时间时，还需要设置唯一编号</li>
<li>主动删除锁的时候，需要判断锁的编号是否和设置的一致，如果一致，则认为是自己设置的锁，可以进行主动删除</li>
</ol>
<img src="H:\images\分布式锁redis\铂金.png" alt="铂金" style="zoom:67%;">

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getTypeEntityListByRedisDistributedLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1.生成唯一ID</span></span><br><span class="line">    String uuid = UUID.randomUUID().toString();</span><br><span class="line">    <span class="comment">// 2.先抢占锁</span></span><br><span class="line">    <span class="keyword">boolean</span> lock = redisTemplate.opsForValue().setIfAbsent(<span class="string">"lock"</span>, uuid, <span class="number">5</span>, TimeUnit.SECONDS);</span><br><span class="line">    <span class="keyword">if</span> (lock) &#123;</span><br><span class="line">        <span class="comment">// 3.抢占锁成功，执行业务</span></span><br><span class="line">        log.info(<span class="string">"[执行业务...]"</span>);</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        <span class="comment">// 4.获取当前锁的值</span></span><br><span class="line">        String value = redisTemplate.opsForValue().get(<span class="string">"lock"</span>);</span><br><span class="line">        <span class="keyword">if</span>(uuid.equals(value)) &#123;</span><br><span class="line">            System.out.println(<span class="string">"释放锁："</span> + value);</span><br><span class="line">            <span class="comment">// 5.如果锁的值和设置的值相等，则清理自己的锁</span></span><br><span class="line">            redisTemplate.delete(<span class="string">"lock"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 休眠一段时间</span></span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        <span class="comment">// 抢占失败，100ms后进行重试，等待锁释放</span></span><br><span class="line">        getTypeEntityListByRedisDistributedLock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>1.生成随机唯一 id，给锁加上唯一值。</li>
<li>2.抢占锁，并设置过期时间为 10 s，且锁具有随机唯一 id。</li>
<li>3.抢占成功，执行业务。</li>
<li>4.执行完业务后，获取当前锁的值。</li>
<li>5.如果锁的值和设置的值相等，则清理自己的锁</li>
</ul>
<h4 id="缺陷-3"><a href="#缺陷-3" class="headerlink" title="缺陷"></a>缺陷</h4><p>第4、第5步并不是原子性的</p>
<ul>
<li>时刻：0s。线程 A 抢占到了锁。</li>
<li>时刻：4.5s 线程 A 向 Redis 查询当前 key 的值，此时因网络波动等原因，还在做查询的操作</li>
<li>时刻：5s。锁自动过期。</li>
<li>时刻：6s。线程 B 抢占到锁。</li>
<li>时刻：7s。线程 A 在终于拿多锁的值value。</li>
<li>时刻：8s。线程 A 还是拿自己设置的锁的值和返回的值进行比较，值是相等的，清理锁，但是这个锁其实是线程 B 抢占的锁</li>
</ul>
<h3 id="方案五：Lua脚本"><a href="#方案五：Lua脚本" class="headerlink" title="方案五：Lua脚本"></a>方案五：Lua脚本</h3><p>上面的线程 A 查询锁、比较锁和删除锁的逻辑不是 <code>原子性</code> 的，所以将查询锁和删除锁这两步作为原子指令操作就可以了</p>
<img src="H:\images\分布式锁redis\钻石.png" alt="钻石" style="zoom:67%;">

<p>那如何用脚本进行删除呢？</p>
<p>我们先来看一下这段 Redis 专属脚本：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> redis.call(<span class="string">"get"</span>, KEYS[1]) == ARGV[1]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">return</span> redis.call(<span class="string">"del"</span>,KEYS[1])</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">return</span> 0</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>这段脚本和铂金方案的获取key，删除key的方式很像。先获取 KEYS[1] 的 value，判断 KEYS[1] 的 value 是否和 ARGV[1] 的值相等，如果相等，则删除 KEYS[1]。</p>
<p>那么这段脚本怎么在 Java 项目中执行呢？</p>
<p>分两步：先定义脚本；用 redisTemplate.execute 方法执行脚本</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getTypeEntityListByRedisDistributedLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 脚本解锁</span></span><br><span class="line">    String script = <span class="string">"if redis.call('get', KEYS[1]) == ARGV[1] then return redis.call('del',KEYS[1]) else return 0 end"</span>;</span><br><span class="line">    <span class="comment">// 1.生成唯一ID</span></span><br><span class="line">    String uuid = UUID.randomUUID().toString();</span><br><span class="line">    <span class="comment">// 2.先抢占锁</span></span><br><span class="line">    <span class="keyword">boolean</span> lock = redisTemplate.opsForValue().setIfAbsent(<span class="string">"lock"</span>, uuid, <span class="number">5</span>, TimeUnit.SECONDS);</span><br><span class="line">    <span class="keyword">if</span> (lock) &#123;</span><br><span class="line">        <span class="comment">// 3.抢占锁成功，执行业务</span></span><br><span class="line">        log.info(<span class="string">"[执行业务...]"</span>);</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        <span class="comment">// 4.执行Lua脚本删锁；KEYS[1]对应"lock"，ARGV[1]对应uuid</span></span><br><span class="line">        redisTemplate.execute(new DefaultRedisScript&lt;&gt;(script, Long.class), Arrays.asList("lock"), uuid);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 休眠一段时间</span></span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        <span class="comment">// 抢占失败，100ms后进行重试，等待锁释放</span></span><br><span class="line">        getTypeEntityListByRedisDistributedLock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而这段 Redis 脚本是由 Redis 内嵌的 Lua 环境执行的，所以又称作 Lua 脚本。</p>
<h4 id="缺陷-4"><a href="#缺陷-4" class="headerlink" title="缺陷"></a>缺陷</h4><p>此方案存在锁过期释放，但是业务还没执行完的问题</p>
<h3 id="终极方案：Redisson"><a href="#终极方案：Redisson" class="headerlink" title="终极方案：Redisson"></a>终极方案：Redisson</h3><h4 id="Redisson-是什么"><a href="#Redisson-是什么" class="headerlink" title="Redisson 是什么"></a>Redisson 是什么</h4><p>如果你之前是在用 Redis 的话，那使用 Redisson 的话将会事半功倍，Redisson 提供了使用 Redis的最简单和最便捷的方法。</p>
<p>Redisson的宗旨是促进使用者对 Redis 的关注分离（Separation of Concern），从而让使用者能够将精力更集中地放在处理业务逻辑上。</p>
<p>Redisson 是一个在 Redis 的基础上实现的 Java 驻内存数据网格（In-Memory Data Grid）</p>
<ul>
<li><strong>Netty 框架</strong>：Redisson采用了基于NIO的Netty框架，不仅能作为Redis底层驱动客户端，具备提供对Redis各种组态形式的连接功能，对Redis命令能以同步发送、异步形式发送、异步流形式发送或管道形式发送的功能，LUA脚本执行处理，以及处理返回结果的功能</li>
<li><strong>基础数据结构</strong>：将原生的Redis <code>Hash</code>，<code>List</code>，<code>Set</code>，<code>String</code>，<code>Geo</code>，<code>HyperLogLog</code>等数据结构封装为Java里大家最熟悉的<code>映射（Map）</code>，<code>列表（List）</code>，<code>集（Set）</code>，<code>通用对象桶（Object Bucket）</code>，<code>地理空间对象桶（Geospatial Bucket）</code>，<code>基数估计算法（HyperLogLog）</code>等结构</li>
<li><strong>分布式数据结构</strong>：这基础上还提供了分布式的多值映射（Multimap），本地缓存映射（LocalCachedMap），有序集（SortedSet），计分排序集（ScoredSortedSet），字典排序集（LexSortedSet），列队（Queue），阻塞队列（Blocking Queue），有界阻塞列队（Bounded Blocking Queue），双端队列（Deque），阻塞双端列队（Blocking Deque），阻塞公平列队（Blocking Fair Queue），延迟列队（Delayed Queue），布隆过滤器（Bloom Filter），原子整长形（AtomicLong），原子双精度浮点数（AtomicDouble），BitSet等Redis原本没有的分布式数据结构。</li>
<li><strong>分布式锁</strong>：Redisson还实现了Redis文档中提到像分布式锁<code>Lock</code>这样的更高阶应用场景。事实上Redisson并没有不止步于此，在分布式锁的基础上还提供了<code>联锁（MultiLock）</code>，<code>读写锁（ReadWriteLock）</code>，<code>公平锁（Fair Lock）</code>，<code>红锁（RedLock）</code>，<code>信号量（Semaphore）</code>，<code>可过期性信号量（PermitExpirableSemaphore）</code>和<code>闭锁（CountDownLatch）</code>这些实际当中对多线程高并发应用至关重要的基本部件。正是通过实现基于Redis的高阶应用方案，使Redisson成为构建分布式系统的重要工具。</li>
<li><strong>节点</strong>：Redisson作为独立节点可以用于独立执行其他节点发布到<code>分布式执行服务</code>和<code>分布式调度服务</code>里的远程任务。</li>
</ul>
<h4 id="整合-Redisson"><a href="#整合-Redisson" class="headerlink" title="整合 Redisson"></a>整合 Redisson</h4><p>Spring Boot 整合 Redisson 有两种方案：</p>
<ul>
<li>程序化配置。</li>
<li>文件方式配置。</li>
</ul>
<p>本篇介绍如何用程序化的方式整合 Redisson</p>
<h4 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.redisson<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>redisson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.15.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="自定义配置类"><a href="#自定义配置类" class="headerlink" title="自定义配置类"></a>自定义配置类</h4><p>下面的代码是单节点 Redis 的配置</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分布式锁 Redisson 配置</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> huawei</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span> huawei_code@163.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/2/22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty</span>(prefix = <span class="string">"redisson"</span>,name = <span class="string">"address"</span>)</span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"redisson"</span>)</span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedissonConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Setter</span></span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">    <span class="meta">@Setter</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="meta">@Setter</span></span><br><span class="line">    <span class="keyword">private</span> Integer database;</span><br><span class="line">    <span class="meta">@Setter</span></span><br><span class="line">    <span class="keyword">private</span> Integer minIdle;<span class="comment">// 默认最小空闲连接数</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对 Redisson 的使用都是通过 RedissonClient 对象</span></span><br><span class="line"><span class="comment">     * destroyMethod="shutdown"：服务停止后调用 shutdown 方法。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span>(destroyMethod=<span class="string">"shutdown"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedissonClient <span class="title">redissonClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Config config = <span class="keyword">new</span> Config();</span><br><span class="line">        SingleServerConfig singleServerConfig = config.useSingleServer();</span><br><span class="line">        <span class="comment">// 集群模式</span></span><br><span class="line">        <span class="comment">// config.useClusterServers().addNodeAddress("127.0.0.1:7004", "127.0.0.1:7001");</span></span><br><span class="line">        singleServerConfig.setAddress(address);</span><br><span class="line">        singleServerConfig.setDatabase(database);</span><br><span class="line">        singleServerConfig.setConnectionMinimumIdleSize(minIdle);</span><br><span class="line">        <span class="keyword">if</span> (StrUtil.isNotBlank(password)) &#123;</span><br><span class="line">            singleServerConfig.setPassword(password);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Redisson.create(config);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="分布式可重入锁"><a href="#分布式可重入锁" class="headerlink" title="分布式可重入锁"></a>分布式可重入锁</h4><p>基于Redis的Redisson分布式可重入锁<code>RLock</code>Java 对象实现了<code>java.util.concurrent.locks.Lock</code>接口。同时还提供了异步（Async）、反射式（Reactive）和RxJava2标准的接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RLock lock = redisson.getLock(<span class="string">"anyLock"</span>);</span><br><span class="line"><span class="comment">// 最常见的使用方法</span></span><br><span class="line">lock.lock();</span><br></pre></td></tr></table></figure>

<p>测试可重入锁的两个点：</p>
<ol>
<li>多个线程抢占锁，后面锁需要等待</li>
<li>如果抢占到锁的线程所在的服务停了或者发生异常了，锁会不会被释放</li>
</ol>
<h5 id="验证一：可重入锁是阻塞的吗"><a href="#验证一：可重入锁是阻塞的吗" class="headerlink" title="验证一：可重入锁是阻塞的吗"></a>验证一：可重入锁是阻塞的吗</h5><p>为了验证以上两点，我写了个 demo 程序：代码的流程就是设置<code>lock</code>锁，然后加锁，打印线程 ID，等待 10 秒后释放锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getTypeEntityListByRedisDistributedLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 抢占锁，只要锁的名字一样，获取的就是同一把锁</span></span><br><span class="line">    RLock lock = redissonClient.getLock(<span class="string">"lock"</span>);</span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        log.info(<span class="string">"加锁成功，执行后续业务代码；线程ID：&#123;&#125;"</span>, Thread.currentThread().getId());</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">        log.info(<span class="string">"Finally，释放锁成功；线程ID：&#123;&#125;"</span>, Thread.currentThread().getId());</span><br><span class="line">    &#125;</span><br><span class="line">    log.info(<span class="string">"输出结果..."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先验证第一个点，用两个 http 请求来测试抢占锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2022</span>-<span class="number">08</span>-<span class="number">09</span> <span class="number">15</span>:<span class="number">42</span>:<span class="number">40.551</span>  INFO <span class="number">41520</span> --- [nio-<span class="number">8055</span>-exec-<span class="number">2</span>]  : 加锁成功，执行后续业务代码；线程ID：<span class="number">76</span></span><br><span class="line"><span class="number">2022</span>-<span class="number">08</span>-<span class="number">09</span> <span class="number">15</span>:<span class="number">42</span>:<span class="number">50.585</span>  INFO <span class="number">41520</span> --- [nio-<span class="number">8055</span>-exec-<span class="number">2</span>]  : Finally，释放锁成功；线程ID：<span class="number">76</span></span><br><span class="line"><span class="number">2022</span>-<span class="number">08</span>-<span class="number">09</span> <span class="number">15</span>:<span class="number">42</span>:<span class="number">50.585</span>  INFO <span class="number">41520</span> --- [nio-<span class="number">8055</span>-exec-<span class="number">2</span>]  : 输出结果...</span><br><span class="line"><span class="number">2022</span>-<span class="number">08</span>-<span class="number">09</span> <span class="number">15</span>:<span class="number">42</span>:<span class="number">50.588</span>  INFO <span class="number">41520</span> --- [nio-<span class="number">8055</span>-exec-<span class="number">1</span>]  : 加锁成功，执行后续业务代码；线程ID：<span class="number">75</span></span><br><span class="line"><span class="number">2022</span>-<span class="number">08</span>-<span class="number">09</span> <span class="number">15</span>:<span class="number">43</span>:<span class="number">00.601</span>  INFO <span class="number">41520</span> --- [nio-<span class="number">8055</span>-exec-<span class="number">1</span>]  : Finally，释放锁成功；线程ID：<span class="number">75</span></span><br><span class="line"><span class="number">2022</span>-<span class="number">08</span>-<span class="number">09</span> <span class="number">15</span>:<span class="number">43</span>:<span class="number">00.601</span>  INFO <span class="number">41520</span> --- [nio-<span class="number">8055</span>-exec-<span class="number">1</span>]  : 输出结果...</span><br></pre></td></tr></table></figure>

<p>第一个线程对应的线程 ID 为 76，10秒后，释放锁。在这期间，第二个线程需要等待锁释放。</p>
<p>第一个线程释放锁之后，第二个线程获取到了锁，10 秒后，释放锁。</p>
<p>由此可以得出结论，Redisson 的可重入锁（lock）是阻塞其他线程的，需要等待其他线程释放的。</p>
<h5 id="验证二：服务停了，锁会释放吗？"><a href="#验证二：服务停了，锁会释放吗？" class="headerlink" title="验证二：服务停了，锁会释放吗？"></a>验证二：服务停了，锁会释放吗？</h5><p>如果线程 A 在等待的过程中，服务突然停了，那么锁会释放吗？如果不释放的话，就会成为死锁，阻塞了其他线程获取锁。</p>
<p>我们先来看下线程 A 的获取锁后的，Redis 客户端查询到的结果：</p>
<img src="H:\images\分布式锁redis\可重入锁.png" alt="可重入锁" style="zoom:67%;">

<p>lock有值，而且大家可以看到 TTL 在不断变小，说明key lock 是自带过期时间的。</p>
<p>通过观察，经过 30 秒后，key lock 过期消失了。说明 Redisson 在停机后或发生异常后，占用的锁会自动释放。</p>
<p>那这又是什么原理呢？这里就要提一个概念了，<code>看门狗</code></p>
<p><strong>锁续期–看门狗原理</strong></p>
<p>对于上面说的方案五存在的问题：<strong>锁过期释放，但业务没执行完</strong>的问题；<strong>如果我们未制定 lock 的超时时间</strong>，redisson会给获得锁的线程，开启一个定时守护线程，每隔一段时间（默认是10s）检查锁是否还存在，存在则对锁的过期时间进行延迟（延迟至默认的30s），防止锁过期提前释放；</p>
<p>当然看门狗的30s超时时间可以通过修改 Config.lockWatchdogTimeout 来另行指定</p>
<p>【<strong>注意</strong>】</p>
<ol>
<li>Redisson 看门狗（Watchdog）在指定加锁时间后，是不会对锁时间自动续租的</li>
<li>看门狗默认续租检查时间是 10s ，<code>internalLockLeaseTime / 3</code>，默认 <code>internalLockLeaseTime</code> 是30s，当然可以通过 Config 统一设置看门狗的时间（internalLockLeaseTime），设置 <code>lockWatchdogTimeout</code> 参数，即可影响续租的检查时间 跟 默认过期时间</li>
</ol>
<h4 id="设置锁过期时间"><a href="#设置锁过期时间" class="headerlink" title="设置锁过期时间"></a>设置锁过期时间</h4><p>我们也可以通过给锁设置过期时间，让其自动解锁。当然这会让看门狗机制失效</p>
<p>如下所示，设置锁 8 秒后自动过期</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lock.lock(<span class="number">5</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>

<p>如果业务执行时间超过 5 秒，手动释放锁将会报错，如下图所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.IllegalMonitorStateException: attempt to unlock lock, not locked by current thread by node id: <span class="number">3349473e-1</span>b1d-<span class="number">40</span>ea-<span class="number">95f</span>e-<span class="number">0</span>c7eae4ed829 thread-id: <span class="number">77</span></span><br></pre></td></tr></table></figure>

<p>所以我们如果设置了锁的自动过期时间，则执行业务的时间一定要小于锁的自动过期时间，否则就会报错</p>
<h3 id="王者"><a href="#王者" class="headerlink" title="王者"></a>王者</h3><p>因为 Redisson 非常强大，实现分布式锁的方案非常简洁，所以称作<code>王者方案</code></p>
<p>原理：</p>
<img src="H:\images\分布式锁redis\王者.png" alt="王者" style="zoom:67%;">

<p>代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.设置分布式锁</span></span><br><span class="line">RLock lock = redisson.getLock(<span class="string">"lock"</span>);</span><br><span class="line"><span class="comment">// 2.占用锁</span></span><br><span class="line">lock.lock();</span><br><span class="line"><span class="comment">// 3.执行业务</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">// 4.释放锁</span></span><br><span class="line">lock.unlock();</span><br></pre></td></tr></table></figure>

<p>和之前 Redis 的方案相比，简洁很多。</p>
<p>下面讲解下 Redisson 的其他几种分布式锁，相信大家在以后的项目中也会用到。</p>
<h4 id="分布式读写锁"><a href="#分布式读写锁" class="headerlink" title="分布式读写锁"></a>分布式读写锁</h4><p>基于 Redis 的 Redisson 分布式可重入读写锁<code>RReadWriteLock</code> Java对象实现了<code>java.util.concurrent.locks.ReadWriteLock</code>接口。其中读锁和写锁都继承了 <code>RLock</code>接口。</p>
<p>写锁是一个排他锁（互斥锁），读锁是一个共享锁。</p>
<ul>
<li>读锁 + 读锁：相当于没加锁，可以并发读。</li>
<li>读锁 + 写锁：写锁需要等待读锁释放锁。</li>
<li>写锁 + 写锁：互斥，需要等待对方的锁释放。</li>
<li>写锁 + 读锁：读锁需要等待写锁释放。</li>
</ul>
<table>
<thead>
<tr>
<th>锁</th>
<th>读</th>
<th>写</th>
</tr>
</thead>
<tbody><tr>
<td>读</td>
<td>并发读</td>
<td>阻塞</td>
</tr>
<tr>
<td>写</td>
<td>阻塞</td>
<td>阻塞</td>
</tr>
</tbody></table>
<p>示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">RReadWriteLock rwlock = redisson.getReadWriteLock(<span class="string">"anyRWLock"</span>);</span><br><span class="line"><span class="comment">// 最常见的使用方法</span></span><br><span class="line">rwlock.readLock().lock();</span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line">rwlock.writeLock().lock();</span><br></pre></td></tr></table></figure>

<p>另外Redisson还通过加锁的方法提供了<code>leaseTime</code>的参数来指定加锁的时间。超过这个时间后锁便自动解开了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 10秒钟以后自动解锁</span></span><br><span class="line"><span class="comment">// 无需调用unlock方法手动解锁</span></span><br><span class="line">rwlock.readLock().lock(<span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line">rwlock.writeLock().lock(<span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试加锁，最多等待100秒，上锁以后10秒自动解锁</span></span><br><span class="line"><span class="keyword">boolean</span> res = rwlock.readLock().tryLock(<span class="number">100</span>, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line"><span class="keyword">boolean</span> res = rwlock.writeLock().tryLock(<span class="number">100</span>, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">...</span><br><span class="line">lock.unlock();</span><br></pre></td></tr></table></figure>

<h3 id="多机实现的分布式锁Redlock-Redisson"><a href="#多机实现的分布式锁Redlock-Redisson" class="headerlink" title="多机实现的分布式锁Redlock+Redisson"></a>多机实现的分布式锁Redlock+Redisson</h3><p>前面的方案都只是基于单机版的讨论，还不是很完美。其实Redis一般都是集群部署的：</p>
<p>如果线程一在Redis的master节点上拿到了锁，但是加锁的key还没同步到slave节点。恰好这时，master节点发生故障，一个slave节点就会升级为master节点。线程二就可以获取同个key的锁啦，但线程一也已经拿到锁了，锁的安全性就没了。</p>
<p>为了解决这个问题，Redis作者 antirez提出一种高级的分布式锁算法：Redlock</p>
<img src="H:\images\分布式锁redis\redis集群抢占锁问题.png" alt="redis集群抢占锁问题" style="zoom:67%;">

      <blockquote class="mdui-m-t-5">
        
          <strong>本文遵循 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank">CC BY-NC-SA 4.0</a> 许可协议，转载请附上原文出处链接和本声明。</strong><br>
        
        <strong>本文链接：</strong><a href="https://yellowbp.github.io/2022/08/08/Redis分布式锁/">https://yellowbp.github.io/2022/08/08/Redis分布式锁/</a>
      </blockquote>
      
    </div>
    <footer class="mdui-card-actions">
      
        <a class="mdui-ripple article_categories-link" href="/categories/Redis/">Redis</a>
      
      
        <a class="mdui-ripple article_tags-link" href="/tags/redis/">redis</a>
      
    </footer>
    
  </article>
  <script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>
<script src="https://cdn.bootcss.com/fancybox/3.5.7/jquery.fancybox.min.js"></script>
  <script>$("#main article .mdui-card-content img.fancybox").on("click",function(e){$.fancybox.open({src:$(this).attr("src")});});</script>


  <nav id="paginator">
    
    <div class="spacer"></div>
    
      <a rel="next" class="extend next" href="/2022/07/31/读取resources目录下的文件路径/">
        下一篇&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        <button aria-label="next" class="mdui-btn mdui-btn-raised mdui-btn-dense mdui-btn-icon mdui-color-theme-accent mdui-ripple"><i class="mdui-icon material-icons">arrow_forward</i></button>
      </a>
    
  </nav>


  <div id="comment" class="mdui-m-t-5">
    <style>#pop_ad,#feedAv{display:none!important;position:absolute!important;z-index:-9999;left:-1000px;opacity:0!important}</style>
<div id="SOHUCS" sid="cl74qc0fr008cjctwtskia79a"></div>
<script type="text/javascript">
(function(){
var appid = 'cyubhC2Dq';
var conf = 'prod_e4cce65003c5bed049fefcb8a6f09e12';
var width = window.innerWidth || document.documentElement.clientWidth;
if (width < 960) {
window.document.write('<script id="changyan_mobile_js" charset="utf-8" type="text/javascript" src="http://changyan.sohu.com/upload/mobile/wap-js/changyan_mobile.js?client_id=' + appid + '&conf=' + conf + '"><\/script>'); } else { var loadJs=function(d,a){var c=document.getElementsByTagName("head")[0]||document.head||document.documentElement;var b=document.createElement("script");b.setAttribute("type","text/javascript");b.setAttribute("charset","UTF-8");b.setAttribute("src",d);if(typeof a==="function"){if(window.attachEvent){b.onreadystatechange=function(){var e=b.readyState;if(e==="loaded"||e==="complete"){b.onreadystatechange=null;a()}}}else{b.onload=a}}c.appendChild(b)};loadJs("http://changyan.sohu.com/upload/changyan.js",function(){window.changyan.api.config({appid:appid,conf:conf})}); } })(); </script>
  </div>



  <div style="position: fixed !important; right: 16px; top: 30%;">
    <button class="mdui-fab mdui-fab-mini mdui-ripple" mdui-menu="{target: '#toc'}"><i class="mdui-icon material-icons">format_list_numbered</i></button>
    <ul class="mdui-menu" id="toc">
      <li class="mdui-menu-item" disabled><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis-分布式锁"><span class="toc-number">1.</span> <span class="toc-text">Redis 分布式锁</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#什么是分布式锁"><span class="toc-number">1.1.</span> <span class="toc-text">什么是分布式锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#分布式锁特性"><span class="toc-number">1.2.</span> <span class="toc-text">分布式锁特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis的setnx"><span class="toc-number">1.3.</span> <span class="toc-text">Redis的setnx</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#分布式方案"><span class="toc-number">1.4.</span> <span class="toc-text">分布式方案</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#方案一：setnx"><span class="toc-number">1.4.1.</span> <span class="toc-text">方案一：setnx</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#缺陷"><span class="toc-number">1.4.1.1.</span> <span class="toc-text">缺陷</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#方案二：setnx-expire"><span class="toc-number">1.4.2.</span> <span class="toc-text">方案二：setnx+ expire</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#原理图"><span class="toc-number">1.4.2.1.</span> <span class="toc-text">原理图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#缺陷-1"><span class="toc-number">1.4.2.2.</span> <span class="toc-text">缺陷</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#方案三：setpx"><span class="toc-number">1.4.3.</span> <span class="toc-text">方案三：setpx</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#原理图-1"><span class="toc-number">1.4.3.1.</span> <span class="toc-text">原理图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#缺陷-2"><span class="toc-number">1.4.3.2.</span> <span class="toc-text">缺陷</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#方案四：sexpx-uuid"><span class="toc-number">1.4.4.</span> <span class="toc-text">方案四：sexpx + uuid</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#缺陷-3"><span class="toc-number">1.4.4.1.</span> <span class="toc-text">缺陷</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#方案五：Lua脚本"><span class="toc-number">1.4.5.</span> <span class="toc-text">方案五：Lua脚本</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#缺陷-4"><span class="toc-number">1.4.5.1.</span> <span class="toc-text">缺陷</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#终极方案：Redisson"><span class="toc-number">1.4.6.</span> <span class="toc-text">终极方案：Redisson</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Redisson-是什么"><span class="toc-number">1.4.6.1.</span> <span class="toc-text">Redisson 是什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#整合-Redisson"><span class="toc-number">1.4.6.2.</span> <span class="toc-text">整合 Redisson</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#依赖"><span class="toc-number">1.4.6.3.</span> <span class="toc-text">依赖</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#自定义配置类"><span class="toc-number">1.4.6.4.</span> <span class="toc-text">自定义配置类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#分布式可重入锁"><span class="toc-number">1.4.6.5.</span> <span class="toc-text">分布式可重入锁</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#验证一：可重入锁是阻塞的吗"><span class="toc-number">1.4.6.5.1.</span> <span class="toc-text">验证一：可重入锁是阻塞的吗</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#验证二：服务停了，锁会释放吗？"><span class="toc-number">1.4.6.5.2.</span> <span class="toc-text">验证二：服务停了，锁会释放吗？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#设置锁过期时间"><span class="toc-number">1.4.6.6.</span> <span class="toc-text">设置锁过期时间</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#王者"><span class="toc-number">1.4.7.</span> <span class="toc-text">王者</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#分布式读写锁"><span class="toc-number">1.4.7.1.</span> <span class="toc-text">分布式读写锁</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#多机实现的分布式锁Redlock-Redisson"><span class="toc-number">1.4.8.</span> <span class="toc-text">多机实现的分布式锁Redlock+Redisson</span></a></li></ol></li></ol></li></ol></li>
    </ul>
  </div>
</main>
  <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
<footer id="footer" class="mdui-m-t-5 mdui-p-y-3 mdui-color-theme">
  <div class="mdui-p-y-0 mdui-text-center">
    
    
    
    
    
    
    
      <a href="https://github.com/yellowbp" target="_blank"><i class="mdui-p-a-1 mdui-icon iconfont mdui-text-color-theme-a100">&#xe7ab;</i></a>
    
    
    
    
    
      <a href="tencent://message/?uin=1432440963&Menu=yes" target="_blank"><i class="mdui-p-a-1 mdui-icon iconfont mdui-text-color-theme-a100">&#xe651;</i></a>
    
    
  </div>
  <div class="mdui-p-y-1 mdui-text-center">
    Copyright &copy; 2019 - 2022 hbp<br>
    Powered by <a href="https://hexo.io/" target="_blank" class="mdui-text-color-theme-accent">Hexo</a>hbp All rights reserved.
    
    <br>
    <span id="busuanzi_container_site_uv">
    本网站总访问量<span id="busuanzi_value_site_uv"></span>次
    </span>
  </div>
</footer>
  <button id="gotop" class="mdui-fab mdui-fab-fixed mdui-fab-hide mdui-ripple mdui-color-theme-accent"><i class="mdui-icon material-icons">arrow_upward</i></button>
  <script async src="http://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  <script src="/js/mdui.js"></script>
<script src="/js/script.js"></script>
</body>
</html>